<script>
  /* ====== Config (unchanged) ====== */
  const CENTROIDS = {
    "Punjab":         { lat: 30.84284696845263, lon: 75.41854251284677 },
    "West Rajasthan": { lat: 27.1589259099715,  lon: 72.70218563309521 },
    "East Rajasthan": { lat: 25.810727217600284,lon: 75.39163711411086 }
  };
  const COLORS = {
    "Clear Sky":            "#66CCFF",
    "Low Cloud Cover":      "#57E66D",
    "Medium Cloud Cover":   "#FFF500",
    "High Cloud Cover":     "#FF8A00",
    "Overcast Cloud Cover": "#FF0000"
  };
  const ICONS = { "Clear Sky":"‚òÄÔ∏è","Low Cloud Cover":"üå§Ô∏è","Medium Cloud Cover":"‚õÖ","High Cloud Cover":"üå•Ô∏è","Overcast Cloud Cover":"‚òÅÔ∏è" };
  function bucketFromPct(p){
    if (p < 10) return "Clear Sky";
    if (p < 30) return "Low Cloud Cover";
    if (p < 50) return "Medium Cloud Cover";
    if (p < 75) return "High Cloud Cover";
    return "Overcast Cloud Cover";
  }
  const CLASS_ROWS = [
    { cover: "0‚Äì10 %",  label: "Clear Sky",            type: "No Cloud" },
    { cover: "10‚Äì30 %", label: "Low Cloud Cover",      type: "Few Clouds" },
    { cover: "30‚Äì50 %", label: "Medium Cloud Cover",   type: "Scattered/Partly Cloudy" },
    { cover: "50‚Äì75 %", label: "High Cloud Cover",     type: "Broken/Mostly Cloudy" },
    { cover: "75‚Äì100 %",label: "Overcast Cloud Cover", type: "Cloudy/Overcast" }
  ];

  /* ====== Robust Open-Meteo fetch with retries & diagnostics ====== */
  function buildOMUrl(lat, lon){
    return `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=cloud_cover&forecast_hours=48&timezone=Asia%2FKolkata`;
  }

  async function fetchHourly(lat, lon){
    const url = buildOMUrl(lat, lon);
    let lastErr;
    for (let attempt=1; attempt<=3; attempt++){
      try{
        const r = await fetch(url, { mode: "cors", cache: "no-store" });
        if (!r.ok){
          const txt = await r.text().catch(()=>"(no body)");
          throw new Error(`HTTP ${r.status} ${r.statusText} ‚Äî ${txt.slice(0,180)}`);
        }
        const j = await r.json();
        const hours = j?.hourly?.time;
        const vals  = j?.hourly?.cloud_cover;
        if (!Array.isArray(hours) || !Array.isArray(vals) || hours.length === 0){
          throw new Error("Malformed payload from Open-Meteo (no hourly.time / hourly.cloud_cover)");
        }
        return { hours, vals };
      }catch(e){
        lastErr = e;
        console.warn(`[Open-Meteo] attempt ${attempt} failed:`, e);
        // small backoff before retry
        await new Promise(res => setTimeout(res, 350*attempt));
      }
    }
    throw lastErr || new Error("Open-Meteo fetch failed");
  }

  /* ====== Load 3 regions + derived Rajasthan ====== */
  async function loadAll(){
    const out = {};
    await Promise.all(Object.entries(CENTROIDS).map(async ([name,{lat,lon}])=>{
      const {hours, vals} = await fetchHourly(lat, lon);
      out[name] = { hours, vals, buckets: vals.map(bucketFromPct) };
    }));
    const wr = out["West Rajasthan"], er = out["East Rajasthan"];
    const hrs = wr.hours.length >= er.hours.length ? wr.hours : er.hours;
    const rzVals = hrs.map((_,i)=> Math.max(wr.vals[i] ?? 0, er.vals[i] ?? 0));
    out["Rajasthan"] = { hours: hrs, vals: rzVals, buckets: rzVals.map(bucketFromPct) };
    return out;
  }

  /* ====== Table rendering (unchanged) ====== */
  function fmtIST(s){
    const d = new Date(s);
    return d.toLocaleString("en-IN", {
      hour: "2-digit", minute: "2-digit",
      weekday: "short", day: "2-digit", month: "short",
      hour12: true, timeZone: "Asia/Kolkata"
    });
  }
  function tdBucket(pct, bucket){
    return `<div class="flex items-center gap-2">
      <span class="inline-block w-3 h-3 rounded" style="background:${COLORS[bucket] || "#eee"}"></span>
      <span class="font-semibold">${Math.round(pct)}%</span>
      <span class="text-xs">${bucket}</span>
      <span>${ICONS[bucket] || ""}</span>
    </div>`;
  }
  function paintTable(data, view="24", filter="all"){
    const body = document.getElementById("hourly-body");
    body.innerHTML = "";
    let s = 0, e = 48;
    if (view === "24") { s = 0; e = 24; }
    if (view === "48") { s = 24; e = 48; }

    const hours = data["Punjab"].hours.slice(s,e);
    for (let i=0;i<hours.length;i++){
      const idx = s+i;
      const tr = document.createElement("tr");
      tr.className = i%2 ? "bg-gray-50/50" : "";

      const p  = data["Punjab"].vals[idx] ?? 0;
      const pb = data["Punjab"].buckets[idx] ?? bucketFromPct(p);
      const w  = data["West Rajasthan"].vals[idx] ?? 0;
      const wb = data["West Rajasthan"].buckets[idx] ?? bucketFromPct(w);
      const eR = data["East Rajasthan"].vals[idx] ?? 0;
      const eb = data["East Rajasthan"].buckets[idx] ?? bucketFromPct(eR);
      const rM = Math.max(w,eR);
      const rb = bucketFromPct(rM);

      let html = "";
      html += `<td class="px-3 py-2">${idx+1}</td>`;
      html += `<td class="px-3 py-2 whitespace-nowrap">${fmtIST(hours[i])}</td>`;
      html += (filter==="all"||filter==="Punjab")          ? `<td class="px-3 py-2">${tdBucket(p,pb)}</td>` : `<td></td>`;
      html += (filter==="all"||filter==="West Rajasthan")  ? `<td class="px-3 py-2">${tdBucket(w,wb)}</td>` : `<td></td>`;
      html += (filter==="all"||filter==="East Rajasthan")  ? `<td class="px-3 py-2">${tdBucket(eR,eb)}</td>` : `<td></td>`;
      html += (filter==="all"||filter==="Rajasthan")       ? `<td class="px-3 py-2">${tdBucket(rM,rb)}</td>` : `<td></td>`;

      tr.innerHTML = html;
      body.appendChild(tr);
    }
  }

  /* ====== Classification table ====== */
  function buildCloudTable(){
    const tb = document.getElementById("cloudTbody");
    if (!tb) return;
    tb.innerHTML = "";
    CLASS_ROWS.forEach((r,i)=>{
      const tr = document.createElement("tr");
      tr.style.background = COLORS[r.label] || "#fff";
      tr.innerHTML = `
        <td class="px-3 py-2">${i+1}</td>
        <td class="px-3 py-2">${r.cover}</td>
        <td class="px-3 py-2 font-semibold">${r.label}</td>
        <td class="px-3 py-2">${r.type}</td>
      `;
      tb.appendChild(tr);
    });
  }

  /* ====== Map (same as you had) ====== */
  const W = 860, H = 580, PAD = 18;
  const MATCH_KEY = "ST_NM";
  let STATE_KEY = "ST_NM", NAME_KEY = "name";
  const GEO_URLS = [
    "indian_met_zones.geojson",
    "assets/indian_met_zones.geojson",
    "bulletin_version_2/indian_met_zones.geojson",
    "https://rimtin.github.io/bulletin_version_2/indian_met_zones.geojson",
    "https://rimtin.github.io/weather_bulletin/indian_met_zones.geojson",
    "https://raw.githubusercontent.com/rimtin/weather_bulletin/main/indian_met_zones.geojson",
    "https://cdn.jsdelivr.net/gh/rimtin/weather_bulletin@main/indian_met_zones.geojson"
  ];
  const norm = s => String(s||"").toLowerCase().normalize("NFKD").replace(/[\u0300-\u036f]/g,"").replace(/[^a-z0-9]+/g," ").replace(/\s+/g," ").trim();
  let mapTooltip=null; function ensureTooltip(){
    if (!mapTooltip){ mapTooltip = d3.select("body").append("div").attr("class","map-tooltip").style("opacity",0); }
    return mapTooltip;
  }
  function detectKeys(features){
    const sKeys=["ST_NM","st_nm","STATE","STATE_UT","NAME_1","state_name","State"];
    const dKeys=["DISTRICT","name","NAME_2","Name","district","dist_name"];
    const sample = features[0]?.properties||{};
    STATE_KEY = sKeys.find(k=>k in sample)||STATE_KEY;
    NAME_KEY  = dKeys.find(k=>k in sample)||NAME_KEY;
  }
  function pickProjection(fc){
    const [[minX,minY],[maxX,maxY]]=d3.geoBounds(fc);
    const w=maxX-minX, h=maxY-minY;
    const lonlat = w<200&&h<120&&minX>=-180&&maxX<=180&&minY>=-90&&maxY<=90;
    return lonlat ? d3.geoMercator().fitExtent([[PAD,PAD],[W-PAD,H-PAD]],fc)
                  : d3.geoIdentity().reflectY(true).fitExtent([[PAD,PAD],[W-PAD,H-PAD]],fc);
  }
  async function fetchFirst(urls){
    for (const url of urls){
      try{ const r=await fetch(url,{cache:"no-cache"}); if(!r.ok) continue; return await r.json(); }catch{}
    } throw new Error("No GeoJSON found");
  }
  const indexByGroup = new Map();
  let mapSvg=null, mapReady=false;

  async function drawHourlyMap(){
    mapReady=false;
    const svg = d3.select("#indiaMapHourly");
    svg.selectAll("*").remove(); mapSvg = svg;

    const defs = svg.append("defs");
    defs.append("pattern").attr("id","diag").attr("patternUnits","userSpaceOnUse").attr("width",6).attr("height",6)
      .append("path").attr("d","M0,0 l6,6").attr("stroke","#9ca3af").attr("stroke-width",1);

    let features=[];
    try{
      const geo = await fetchFirst(GEO_URLS);
      features = (geo.type==="Topology")
        ? topojson.feature(geo, geo.objects[Object.keys(geo.objects)[0]]).features
        : (geo.features||[]);
    }catch(e){ console.error(e); alert("Could not load GeoJSON"); return; }
    if(!features.length) { alert("GeoJSON has 0 features"); return; }

    detectKeys(features);
    const fc = { type:"FeatureCollection", features };
    const projection = pickProjection(fc);
    const path = d3.geoPath(projection);

    const fillLayer = svg.append("g").attr("class","fill-layer");
    const paths = fillLayer.selectAll("path").data(features).join("path")
      .attr("class","subdiv")
      .attr("data-st", d => d.properties?.[STATE_KEY] ?? "")
      .attr("data-d",  d => d.properties?.[NAME_KEY]  ?? "")
      .attr("d", path)
      .attr("fill", "url(#diag)")
      .attr("stroke", "#666").attr("stroke-width", .7);

    const allowed = new Set(["punjab","west rajasthan","east rajasthan"]);
    const tt = ensureTooltip();
    paths.on("pointermove", function(evt,d){
      const raw = d?.properties?.[STATE_KEY] ?? "";
      const key = norm(raw);
      if (!allowed.has(key)) { tt.style("opacity",0); return; }
      const pad=12, vw=innerWidth, vh=innerHeight, w=200, h=40;
      let x=evt.clientX+pad, y=evt.clientY+pad; if(x+w>vw)x=vw-w-pad; if(y+h>vh)y=vh-h-pad;
      tt.style("opacity",1).html(raw).style("left",x+"px").style("top",y+"px");
    }).on("pointerleave", ()=>tt.style("opacity",0));

    indexByGroup.clear();
    paths.each(function(d){
      const key = norm(String(d.properties?.[STATE_KEY] ?? ""));
      if (!key) return;
      (indexByGroup.get(key) || indexByGroup.set(key, []).get(key)).push(this);
    });

    mapReady=true;
  }

  function colorMapForHour(dataset, hourIdx){
    if (!mapReady) return;
    const svg = mapSvg;
    svg.selectAll(".subdiv").attr("fill","url(#diag)");
    const pairs = [
      ["punjab",         dataset["Punjab"].buckets[hourIdx]],
      ["west rajasthan", dataset["West Rajasthan"].buckets[hourIdx]],
      ["east rajasthan", dataset["East Rajasthan"].buckets[hourIdx]]
    ];
    pairs.forEach(([key,bucket])=>{
      const nodes = indexByGroup.get(key);
      if (!nodes) return;
      const c = COLORS[bucket] || "#eee";
      nodes.forEach(n => n.setAttribute("fill", c));
    });
  }

  /* ====== Page wiring + diagnostics ====== */
  let CACHE=null, view="24", filter="all", hourIndex=0;

  function updateNowIST(){
    const now = new Date();
    const el = document.getElementById("now-ist");
    if (el) el.textContent =
      now.toLocaleString("en-IN",{ timeZone:"Asia/Kolkata", hour:'2-digit', minute:'2-digit', weekday:'long', year:'numeric', month:'long', day:'numeric', hour12:true });
  }

  function updateHourLabel(data){
    const s = data["Punjab"]?.hours?.[hourIndex];
    const el = document.getElementById("hourLabel");
    if (el) el.textContent = s ? fmtIST(s) : "‚Äî";
  }

  function repaint(){
    if (!CACHE) return;
    paintTable(CACHE, view, filter);
    updateHourLabel(CACHE);
    colorMapForHour(CACHE, hourIndex);
  }

  document.addEventListener("DOMContentLoaded", async ()=>{
    updateNowIST(); setInterval(updateNowIST, 60000);
    buildCloudTable();
    await drawHourlyMap();

    try{
      CACHE = await loadAll();
    }catch(e){
      console.error("Open-Meteo fetch failed:", e);
      const tester = buildOMUrl(CENTROIDS["Punjab"].lat, CENTROIDS["Punjab"].lon);
      alert(`Could not load hourly cloud cover from Open-Meteo.\n\nReason: ${e.message}\n\nTroubleshooting:\n‚Ä¢ Click OK, then open this test link in a new tab to confirm network access:\n${tester}\n‚Ä¢ If the link fails, your network/firewall is blocking api.open-meteo.com.`);
      return;
    }

    repaint();

    document.getElementById("btn24").addEventListener("click", ()=>{ view="24"; repaint(); });
    document.getElementById("btn48").addEventListener("click", ()=>{ view="48"; repaint(); });
    document.getElementById("btnAll").addEventListener("click", ()=>{ view="all"; repaint(); });
    document.getElementById("zoneSelect").addEventListener("change", (e)=>{ filter=e.target.value; repaint(); });
    document.getElementById("btnRefresh").addEventListener("click", async ()=>{
      try{ CACHE = await loadAll(); repaint(); }
      catch(e){ console.error("Refresh failed:", e); alert(`Refresh failed: ${e.message}`); }
    });

    const slider = document.getElementById("hourSlider");
    slider.addEventListener("input", e => { hourIndex = +e.target.value; updateHourLabel(CACHE); colorMapForHour(CACHE, hourIndex); });
    document.getElementById("satBtn").addEventListener("click", ()=>{
      window.open("https://zoom.earth/#view=22.5,79.0,5z/layers=labels,clouds","_blank","noopener");
    });
  });
</script>
